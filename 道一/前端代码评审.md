[TOC]

# 前端代码评审

代码评审（Code Review)）是软件开发中常用的手段，和QA测试相比，它更容易发现非功能性、与架构相关等较难发现的问题，还可以帮助团队成员提高编程技能，统一编程风格等。



## 评审原因

持续、有效的开展代码审查，将会收获许多收益，具体表现在：

+ 能及时发现代码中的Bug，保证版本质量，尤其是体现在开发产品上面。
+ 提升代码的可读性、可维护性，建立团队共同的编码风格。
+ 通过讲解自己的代码，对个人沟通能力也是一种提升。
+ 提高开发者的对编码的责任感。



## 代码规范

lint规范工具检查只能让大家的编码风格保持一致性，却无法避免低质量输出的问题。而这种问题对团队和产品来说往往却是致命的。

什么样的代码是好的，什么样的代码是不好的？这来源于知识的学习运用和开发经验的日积月累。低质量的编码说到底还是经验不同、水平存在差异。对于个人来说要通过不断的学习积累自我提升，对于团队来说进行代码规范是有必要的。



### 合并重复的条件片段

如果一段代码或者函数体内有一些条件分支语句，而这些条件分支语句内部散布了一些重复的代码， 那么就有必要进行合并去重工作。

```js
// bad
var paging = function (currPage) {
  if (currPage <= 0) {
    currPage = 0;
    jump(currPage); // 跳转
  } else if (currPage >= totalPage) {
    currPage = totalPage;
    jump(currPage); // 跳转
  } else {
    jump(currPage); // 跳转
  }
};

//可以看到，负责跳转的代码 jump( currPage )在每个条件分支内都出现了，所以完全可以把这句代码独立出来：

// good
var paging = function (currPage) {
  if (currPage <= 0) {
    currPage = 0;
  } else if (currPage >= totalPage) {
    currPage = totalPage;
  }
  jump(currPage); // 把 jump 函数独立出来
};
```



### 必要的类型判断

由于js是动态弱类型语言，优点是写法灵活不受类型的限制，但缺点是不同类型的赋值不能在编译期间发现问题，从而导致潜在的bug。

使用必要的类型判断，可以大大增加代码的健壮性，防止没传递参数或者参数类型错误导致程序执行报错，保证程序按照预想的流程执行，减少报错几率。

**判断是否为函数：**

```js
// bad
function foo(cb) {
  // ... do something
  cb()
}
foo()

// good
function foo(cb) {
  // ... do something
  cb && cb()
}
foo()

// better
function foo(cb) {
  // ... do something
  typeof cb === 'function' && cb()
}
foo()
```

**判断是否为undefined：**

```js
// bad
x === undefined

// good
typeof x === 'undefined'
```



### 将对象的属性值保存为局部变量

对象成员嵌套越深，读取速度也就越慢。所以好的做法是：如果需要多次读取一个对象属性，最佳做法是将该属性值保存在局部变量中，避免多次查找带来的性能开销。（尤其是在多次访问该对象的属性值的情况下）

**对象：**

```js
const person = {
  info: {
    sex: '男'
  }
}
// bad
function getMaleSex() {
  if (person.info.sex === '男') {
    console.log(person.info.sex)
  }
}

// good
function getMaleSex() {
  const sex = person.info.sex;  // 将该属性值保存在局部变量中
  if (sex === '男') {
    console.log(sex)
  }
}
```



**数组：**

```js
var arr = Array.from({ length: 1000 }, (k, v) => v) // 创建一个长度为1000，值为从0开始到999的数组
console.time()
// bad
for (let i = 0; i < arr.length; i++) {
  // ... do something
}
console.timeEnd()

console.time()
// good
for (let i = 0, len = arr.length; i < len; i++) {
  // ... do something
}
console.timeEnd()
```



### 传递对象参数代替过长的函数参数列表

函数参数越少越好，如果参数超过三个，就可以考虑传递对象来替代。

```js
// bad
function createMenu(title, body, buttonText, cancellable) {
  // ... do something
}
createMenu('Foo', 'bar', 'Baz', true)

// good
function createMenu({ title, body, buttonText, cancellable }) { // 这里使用到ES6的解构赋值语法
  // ... do something
}
createMenu({
  title: 'Foo',
  body: 'Bar',
  buttonText: 'Baz',
  cancellable: true
});

// 好处：函数需要的数据可以自行从该对象里获取。现在不用再关心参数的数量和顺序，只要保证参数对应的 key 值不变即可。
```



### 使用参数默认值

函数形参可以指定默认值，来减少由于没传递参数出现函数执行错误的几率。可以使用ES6的默认参数语法替代使用条件语句进行赋值。

```js
// bad
function foo(name) {
  // ... use name to do something
}

// good
function foo(name) {
  name = name || 'tom'
  // ... use name to do something
}

// better
function foo(name = 'tom') {
  // ... use name to do something
}
```



### **保持必要的注释**

代码注释不是越多越好，保持必要的业务逻辑注释，至于函数的用途、代码逻辑等，要通过语义化的命令、简单明了的代码逻辑，来让阅读代码的人快速看懂。

**js文件开头，介绍文件作用描述、作者，编写日期等信息：**

```js
/**
 * @description 工具类函数
 * @author 陈泽华
 * @date 2021-05-25
 */
```

**js函数注释信息：**

```js
/**
 * 递归判断跳转页面路径是否在权限菜单内
 * @param {string} path 跳转的页面路径
 * @param {Array} menu 菜单列表
 * @returns {boolean} 是否有权限
 */
export const hasMenuPermission = function fn(path, menu) {
  if (menu.some(item => item.url === path)) {
    return true
  }

  for (const menuItem of menu) {
    if (menuItem.list) {
      const result = fn(path, menuItem.list)
      if (result) return true
    }
  }

  return false
}
```



### 尽量使用字面量

创建对象和数组推荐使用字面量，因为这不仅是性能最优也有助于节省代码量。

```js
// bad
const obj = {};
obj.name = 'tom';
obj.age = 15;
obj.sex = '男';

// good
const obj = {   
	name:'tom',     
	age:15,     
	sex:'男' 
} 
```



### 推荐函数式编程

函数式变编程可以让代码简洁、逻辑清晰和易于理解。

```js
const balls = [
  {
    name: 'football',
    count: 100
  }, {
    name: 'basketball',
    count: 200
  }, {
    name: 'volleyball',
    count: 300
  }
]
// bad
let totalCount = 0;
for (let i = 0; i < balls.length; i++) {
  totalCount += balls[i].count;
}

// good
const totalCount = balls
  .map(item => item.count)
  .reduce((accu, curr) => accu + curr)
```



### 提取常量配置文件

使用scss可以进行项目的颜色、字体大小统一更改（换肤），有利于后期主题变更：

```scss
$primary-color: #5585f0; // 全局主色
$normal-font-size: 14px; // 普通字体大小
```

使用js创建项目的全局常量配置文件，有利于后期项目的维护：

```js
// constant.js
// 账户状态
const PERSON_STATUS = {
  NORMAL: 1, // 正常
  DISABLED: 2, // 禁用
  RESIGNED: 3, // 离职
  VERIFIED: 4, // 已认证
  UNVERIFIED: 5 // 未认证
}

// 账户状态映射
const PERSON_STATUS_MAP = {
  [PERSON_STATUS.NORMAL]: '正常',
  [PERSON_STATUS.DISABLED]: '禁用',
  [PERSON_STATUS.RESIGNED]: '离职',
  [PERSON_STATUS.VERIFIED]: '已认证',
  [PERSON_STATUS.UNVERIFIED]: '未认证'
}
```

```vue
<!-- index.vue -->
<!-- bad -->
<template>
	<div v-for="(item, index) in list" :key="index">
    <span v-if="item.type === 1">正常</span>
    <span v-else-if="item.type === 2">禁用</span>
    <span v-else-if="item.type === 3">离职</span>
    <span v-else-if="item.type === 4">已认证</span>
    <span v-else-if="item.type === 5">未认证</span>
  </div>
</template>

 <!-- good -->
<template>
	<div v-for="(item, index) in list" :key="index">
    <span>{{ PERSON_STATUS_MAP[item.type] }}</span>
  </div>
</template>
<script>
import { PERSON_STATUS_MAP } from 'xxx/constant.js'
export default {
  data() {
    return {
      PERSON_STATUS_MAP
    }
  }
}
</script>
```



### 慎用三元运算符

有一些程序员喜欢大规模地使用三元运算符，来代替传统的 if、else。理由是三元运算符性 能高，代码量少。不过，这两个理由其实都很难站得住脚。

三元运算符的效率比 if、else 高，这点差距也是完全可以忽略不计的。 在实际的开发中，即使把一段代码循环一百万次，使用三元运算符和使用 if、else 的时间开销 处在同一个级别里。

同样，相比损失的代码可读性和可维护性，三目运算符节省的代码量也可以忽略不计。

如果条件分支逻辑简单且清晰，这无碍我们使用三元运算符：

```js
var global = typeof window !== "undefined" ? window : this
```

但如果条件分支逻辑非常复杂，如下段代码所示，那我们最好的选择还是按部就班地编写 if、else。if、else 语句的好处很多，一是阅读相对容易，二是修改的时候比修改三元运算符周围的代码更加方便： 

```js
if (!aup || !bup) {
  return a === doc ? -1 :
    b === doc ? 1 :
      aup ? -1 :
        bup ? 1 :
          sortInput ?
            (indexOf.call(sortInput, a) - indexOf.call(sortInput, b)) :
            0;
}
```



### 合理使用链式调用

经常使用 jQuery 的程序员相当习惯链式调用方法：

```js
// bad
var $this = $(this)
$this.addClass('active')
var siblings = $this.siblings()
siblings.removeClass('active')

// good
$(this)
  .addClass('active')
  .siblings()
  .removeClass('active')
```

在 JavaScript 中，可以很容易地实现方法的链式调用，即让方法调用结束后返回对象：

```js
var User = {
  id: null,
  name: null,
  setId: function (id) {
    this.id = id;
    return this;
  },
  setName: function (name) {
    this.name = name;
    return this;
  }
};
console.log(User.setId(9527).setName('tom'));
```



### 命名符合语义化

命名需要符合语义化，例如函数命名，可以采用加上动词前缀：

| 动词 | **含义**               | 例子                            |
| ---- | ---------------------- | ------------------------------- |
| can  | 判断是否可执行某个动作 | canSendCode：是否可以发送验证码 |
| has  | 判断是否含有某个值     | hasChild：是否含有子节点        |
| is   | 判断是否为某个值       | isLeaf：是否为叶子节点          |
| get  | 获取某个值             | setUserInfo：获取用户信息       |
| set  | 设置某个值             | getUserInfo：设置用户信息       |



## 规范工具

光是靠开发人员自我约束并不可靠，必须使用规范工具来强制约束。在大团队协作时，使用规范工具来约束代码规范是非常必要的。

### eslint

使用 eslint 工具对 javascript 代码进行检查。

[参考文档](https://cloud.tencent.com/developer/section/1135570)



### stylelint

使用 stylelint 工具对 css 样式代码进行检查。

[参考文档](https://cloud.tencent.com/developer/section/1489626)
